{"version":3,"file":"avl.js","sources":["../src/utils.ts","../src/index.ts"],"sourcesContent":["import { Node, PrintCallback } from './types'\n\n/** Default comparison function */\nexport function DEFAULT_COMPARE<K = unknown>(a: K, b: K): number {\n    return a > b ? 1 : a < b ? -1 : 0\n}\n\n/** Single left rotation */\nexport function rotateLeft<K = unknown, V = unknown>(\n    node: Node<K, V>,\n): Node<K, V> | undefined {\n    const rightNode = node.right\n    if (!rightNode) return\n    node.right = rightNode.left\n\n    if (rightNode.left) rightNode.left.parent = node\n\n    rightNode.parent = node.parent\n    if (rightNode.parent) {\n        if (rightNode.parent.left === node) {\n            rightNode.parent.left = rightNode\n        } else {\n            rightNode.parent.right = rightNode\n        }\n    }\n\n    node.parent = rightNode\n    rightNode.left = node\n\n    node.balanceFactor += 1\n    if (rightNode.balanceFactor < 0) {\n        node.balanceFactor -= rightNode.balanceFactor\n    }\n\n    rightNode.balanceFactor += 1\n    if (node.balanceFactor > 0) {\n        rightNode.balanceFactor += node.balanceFactor\n    }\n    return rightNode\n}\n\nexport function rotateRight<K = unknown, V = unknown>(\n    node: Node<K, V>,\n): Node<K, V> | undefined {\n    const leftNode = node.left\n    if (!leftNode) return\n    node.left = leftNode.right\n    if (node.left) node.left.parent = node\n\n    leftNode.parent = node.parent\n    if (leftNode.parent) {\n        if (leftNode.parent.left === node) {\n            leftNode.parent.left = leftNode\n        } else {\n            leftNode.parent.right = leftNode\n        }\n    }\n\n    node.parent = leftNode\n    leftNode.right = node\n\n    node.balanceFactor -= 1\n    if (leftNode.balanceFactor > 0) {\n        node.balanceFactor -= leftNode.balanceFactor\n    }\n\n    leftNode.balanceFactor -= 1\n    if (node.balanceFactor < 0) {\n        leftNode.balanceFactor += node.balanceFactor\n    }\n\n    return leftNode\n}\n\n/** Print tree horizontally */\nexport function print<K = unknown, V = unknown>(\n    root: Node<K, V> | undefined,\n    printNode: PrintCallback<K, V> = (node: Node<K, V>) => String(node.key),\n): string {\n    const out: Array<string> = []\n    row(root, '', true, (v) => out.push(v), printNode)\n    return out.join('')\n}\n\n/** Print level of the tree */\nfunction row<K = unknown, V = unknown>(\n    root: Node<K, V> | undefined,\n    prefix: string,\n    isTail: boolean,\n    out: (xin: string) => void,\n    printNode: PrintCallback<K, V>,\n) {\n    if (root) {\n        out(`${prefix}${isTail ? '└── ' : '├── '}${printNode(root)}\\n`)\n        const indent = prefix + (isTail ? '    ' : '│   ')\n        if (root.left) row(root.left, indent, false, out, printNode)\n        if (root.right) row(root.right, indent, true, out, printNode)\n    }\n}\n\n/**\n * Is the tree balanced (none of the subtrees differ in height by more than 1)\n */\nexport function isBalanced<K = unknown, V = unknown>(\n    root: Node<K, V> | undefined,\n): boolean {\n    if (!root) return true // If node is empty then return true\n\n    // Get the height of left and right sub trees\n    const lh = height(root.left)\n    const rh = height(root.right)\n\n    if (\n        Math.abs(lh - rh) <= 1 &&\n        isBalanced(root.left) &&\n        isBalanced(root.right)\n    ) {\n        return true\n    }\n\n    // If we reach here then tree is not height-balanced\n    return false\n}\n\n/**\n * Compute the 'height' of a tree.\n * Height is the number of nodes along the longest path\n * from the root node down to the farthest leaf node.\n */\nfunction height<K = unknown, V = unknown>(\n    node: Node<K, V> | undefined,\n): number {\n    return node ? 1 + Math.max(height(node.left), height(node.right)) : 0\n}\n\nexport function loadRecursive<K = unknown, V = unknown>(\n    parent: Node<K, V> | undefined,\n    keys: K[],\n    values: V[],\n    start: number,\n    end: number,\n) {\n    const size = end - start\n    if (size > 0) {\n        const middle = start + Math.floor(size / 2)\n        const key = keys[middle]\n        const data = values[middle]\n        const node: Node<K, V> = { key, data, parent, balanceFactor: 0 }\n        node.left = loadRecursive(node, keys, values, start, middle)\n        node.right = loadRecursive(node, keys, values, middle + 1, end)\n        return node\n    }\n}\n\nexport function markBalance<K = unknown, V = unknown>(\n    node: Node<K, V> | undefined,\n): number {\n    if (!node) return 0\n    const lh = markBalance(node.left)\n    const rh = markBalance(node.right)\n\n    node.balanceFactor = lh - rh\n    return Math.max(lh, rh) + 1\n}\n\nexport function sort<K = unknown, V = unknown>(\n    keys: Array<K>,\n    values: Array<V>,\n    left: number,\n    right: number,\n    compare: (a: K, b: K) => number,\n) {\n    if (left >= right) return\n\n    // eslint-disable-next-line no-bitwise\n    const pivot = keys[(left + right) >> 1]\n    let i = left - 1\n    let j = right + 1\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        do i++\n        while (compare(keys[i], pivot) < 0)\n        do j--\n        while (compare(keys[j], pivot) > 0)\n        if (i >= j) break\n\n        const tmpK: K = keys[i]\n        keys[i] = keys[j]\n        keys[j] = tmpK\n\n        const tmpV: V = values[i]\n        values[i] = values[j]\n        values[j] = tmpV\n    }\n\n    sort(keys, values, left, j, compare)\n    sort(keys, values, j + 1, right, compare)\n}\n","import {\n    BareNode,\n    Comparator,\n    ForEachCallback,\n    Node,\n    TraverseCallback,\n} from './types'\nimport {\n    DEFAULT_COMPARE,\n    isBalanced,\n    loadRecursive,\n    markBalance,\n    print,\n    rotateLeft,\n    rotateRight,\n    sort,\n} from './utils'\n\nclass AVLTree<K, V> {\n    private _comparator: Comparator<K>\n    private _root: Node<K, V> | undefined\n    private _size = 0\n    private _noDuplicates: boolean\n\n    constructor(comparator?: Comparator<K>, noDuplicates = false) {\n        this._comparator = comparator || DEFAULT_COMPARE\n        this._noDuplicates = !!noDuplicates\n    }\n\n    /** Number of nodes */\n    get size(): number {\n        return this._size\n    }\n\n    /** Clear the tree */\n    clear(): AVLTree<K, V> {\n        delete this._root\n        this._size = 0\n        return this\n    }\n\n    /** Clear the tree (alias for `clear`) */\n    destroy(): AVLTree<K, V> {\n        return this.clear()\n    }\n\n    /** Check if tree contains a node with the given key */\n    contains(key: K): boolean {\n        if (this._root) {\n            let node: Node<K, V> | undefined = this._root\n            const comparator = this._comparator\n            while (node) {\n                const cmp = comparator(key, node.key)\n                if (cmp === 0) return true\n                else if (cmp < 0) node = node.left\n                else node = node.right\n            }\n        }\n        return false\n    }\n\n    /**\n     * Execute `callback` on every node of the tree, in order.\n     * Return a 'truthy' value from `callback` to stop the iteration.\n     */\n    forEach(callback: ForEachCallback<K, V>): AVLTree<K, V> {\n        let current: Node<K, V> | undefined = this._root\n        const s: Array<Node<K, V>> = []\n        let done: boolean | undefined = false\n        let i = 0\n        while (!done) {\n            // Reach the left most Node of the current Node\n            if (current) {\n                // Place pointer to a tree node on the stack\n                // before traversing the node's left subtree\n                s.push(current)\n                current = current.left\n            } else {\n                // Backtrack from the empty subtree and visit the Node\n                // at the top of the stack; however, if the stack is\n                // empty you are done\n                if (s.length > 0) {\n                    current = s.pop() as Node<K, V>\n                    done = !!callback(current, i++)\n                    // We have visited the node and its left\n                    // subtree. Now, it is the right subtree's turn\n                    current = current.right\n                } else {\n                    done = true\n                }\n            }\n        }\n        return this\n    }\n\n    /** Walk key range from `low` to `high`. Stop if `fn` returns a value. */\n    range(\n        low: K,\n        high: K,\n        fn: TraverseCallback<K, V>,\n        ctx?: unknown,\n    ): AVLTree<K, V> {\n        const Q: Array<Node<K, V>> = []\n        const compare = this._comparator\n        let node = this._root\n        let cmp: number\n        while (Q.length !== 0 || node) {\n            if (node) {\n                Q.push(node)\n                node = node.left\n            } else {\n                node = Q.pop() as Node<K, V>\n                cmp = compare(node.key, high)\n                if (cmp > 0) {\n                    break\n                } else if (compare(node.key, low) >= 0) {\n                    if (fn.call(ctx, node)) {\n                        // stop if something is returned\n                        return this\n                    }\n                }\n                node = node.right\n            }\n        }\n        return this\n    }\n\n    /** Array of all keys, in order */\n    keys(): Array<K> {\n        const r: Array<K> = []\n        this.forEach((node) => r.push(node.key as K))\n        return r\n    }\n\n    /** Array of `data` field values of all nodes, in order */\n    values(): Array<V> {\n        const r: Array<V> = []\n        this.forEach((node) => r.push(node.data as V))\n        return r\n    }\n\n    /** Return node at given `index` */\n    at(index: number): Node<K, V> | undefined {\n        let r: Node<K, V> | undefined\n        this.forEach((node, i) => {\n            if (i === index) return (r = node)\n        })\n        return r\n    }\n\n    /** Return node with the minimum key */\n    minNode(): Node<K, V> | undefined {\n        let node = this._root\n        if (!node) return\n        while (node.left) {\n            node = node.left\n        }\n        return node\n    }\n\n    /** Return node with the maximum key */\n    maxNode(): Node<K, V> | undefined {\n        let node = this._root\n        if (!node) return\n        while (node.right) {\n            node = node.right\n        }\n        return node\n    }\n\n    /** Return the minimum key */\n    min(): K | undefined {\n        const node = this.minNode()\n        if (!node) return\n        return node.key\n    }\n\n    /** Return the maximum key */\n    max(): K | undefined {\n        const node = this.maxNode()\n        if (!node) return\n        return node.key\n    }\n\n    /** Return true if tree is empty */\n    isEmpty(): boolean {\n        return !this._root\n    }\n\n    /** Remove (and return) the node with minimum key */\n    pop(): BareNode<K, V> | undefined {\n        let node = this._root\n        let returnValue: BareNode<K, V> | undefined\n        if (node) {\n            while (node.left) {\n                node = node.left\n            }\n            returnValue = { key: node.key, data: node.data }\n            this.remove(node.key)\n        }\n        return returnValue\n    }\n\n    /** Remove (and return) the node with maximum key */\n    popMax(): BareNode<K, V> | undefined {\n        let node = this._root\n        let returnValue: BareNode<K, V> | undefined\n        if (node) {\n            while (node.right) {\n                node = node.right\n            }\n            returnValue = { key: node.key, data: node.data }\n            this.remove(node.key)\n        }\n        return returnValue\n    }\n\n    /** Find node by key */\n    find(key: K): Node<K, V> | undefined {\n        let subtree = this._root\n        let cmp: number\n        const compare = this._comparator\n        while (subtree) {\n            cmp = compare(key, subtree.key)\n            if (cmp === 0) return subtree\n            else if (cmp < 0) subtree = subtree.left\n            else subtree = subtree.right\n        }\n    }\n\n    /** Insert a node into the tree */\n    insert(key: K, data?: V): Node<K, V> | undefined {\n        if (!this._root) {\n            this._root = {\n                parent: undefined,\n                left: undefined,\n                right: undefined,\n                balanceFactor: 0,\n                key,\n                data,\n            }\n            this._size++\n            return this._root\n        }\n\n        const compare = this._comparator\n        let node: Node<K, V> | undefined = this._root\n        let parent: Node<K, V> | undefined = this._root\n        let cmp = 0\n\n        if (this._noDuplicates) {\n            while (node) {\n                cmp = compare(key, node.key)\n                parent = node\n                if (cmp === 0) return\n                else if (cmp < 0) node = node.left\n                else node = node.right\n            }\n        } else {\n            while (node) {\n                cmp = compare(key, node.key)\n                parent = node\n                if (cmp <= 0) node = node.left\n                else node = node.right\n            }\n        }\n\n        const newNode: Node<K, V> = {\n            left: undefined,\n            right: undefined,\n            balanceFactor: 0,\n            parent,\n            key,\n            data,\n        }\n        let newRoot: Node<K, V> | undefined\n        if (cmp <= 0) parent.left = newNode\n        else parent.right = newNode\n\n        while (parent) {\n            cmp = compare(parent.key, key)\n            if (cmp < 0) parent.balanceFactor -= 1\n            else parent.balanceFactor += 1\n\n            if (parent.balanceFactor === 0) {\n                break\n            } else if (parent.balanceFactor < -1) {\n                if (parent.right?.balanceFactor === 1) {\n                    rotateRight(parent.right)\n                }\n                newRoot = rotateLeft(parent)\n                if (parent === this._root) {\n                    this._root = newRoot\n                }\n                break\n            } else if (parent.balanceFactor > 1) {\n                if (parent.left?.balanceFactor === -1) {\n                    rotateLeft(parent.left)\n                }\n                newRoot = rotateRight(parent)\n                if (parent === this._root) {\n                    this._root = newRoot\n                }\n                break\n            }\n            parent = parent.parent\n        }\n\n        this._size++\n        return newNode\n    }\n\n    /** Remove the node from the tree. */\n    remove(key: K | undefined): K | undefined {\n        if (!this._root || !key) return\n        let node: Node<K, V> | undefined = this._root\n        const compare = this._comparator\n        let cmp = 0\n\n        // Start at the root, advance down the tree checking for a match.\n        while (node) {\n            cmp = compare(key, node.key)\n            if (cmp === 0) break\n            // found it!\n            else if (cmp < 0) node = node.left\n            else node = node.right\n        }\n        // If we reached the end of the tree, the key is not in the tree.\n        if (!node) return\n\n        const returnValue = node.key\n        let max: Node<K, V>\n        let min: Node<K, V>\n\n        if (node.left) {\n            max = node.left\n\n            while (max.left || max.right) {\n                while (max.right) {\n                    max = max.right\n                }\n                node.key = max.key\n                node.data = max.data\n                if (max.left) {\n                    node = max\n                    max = max.left\n                }\n            }\n\n            node.key = max.key\n            node.data = max.data\n            node = max\n        }\n\n        if (node.right) {\n            min = node.right\n\n            while (min.left || min.right) {\n                while (min.left) {\n                    min = min.left\n                }\n                node.key = min.key\n                node.data = min.data\n                if (min.right) {\n                    node = min\n                    min = min.right\n                }\n            }\n\n            node.key = min.key\n            node.data = min.data\n            node = min\n        }\n\n        let parent: Node<K, V> | undefined = node.parent\n        let pp: Node<K, V> | undefined = node\n        let newRoot: Node<K, V> | undefined\n\n        while (parent) {\n            if (parent.left === pp) parent.balanceFactor -= 1\n            else parent.balanceFactor += 1\n\n            if (parent.balanceFactor < -1) {\n                if (parent.right?.balanceFactor === 1) {\n                    rotateRight(parent.right)\n                }\n                newRoot = rotateLeft(parent)\n                if (parent === this._root) {\n                    this._root = newRoot\n                }\n                parent = newRoot\n            } else if (parent.balanceFactor > 1) {\n                if (parent.left?.balanceFactor === -1) {\n                    rotateLeft(parent.left)\n                }\n                newRoot = rotateRight(parent)\n                if (parent === this._root) {\n                    this._root = newRoot\n                }\n                parent = newRoot\n            }\n\n            if (parent?.balanceFactor === -1 || parent?.balanceFactor === 1) {\n                break\n            }\n            pp = parent\n            parent = parent?.parent\n        }\n\n        if (node.parent) {\n            if (node.parent.left === node) {\n                delete node.parent.left\n            } else {\n                delete node.parent.right\n            }\n        }\n\n        if (node === this._root) {\n            delete this._root\n        }\n\n        this._size--\n        return returnValue\n    }\n\n    /** Bulk-load items (into an empty tree only) */\n    load(keys: Array<K> = [], values: Array<V> = [], presort?: boolean) {\n        if (this._size !== 0) throw new Error('bulk-load: tree is not empty')\n        const size = keys.length\n        if (presort) sort(keys, values, 0, size - 1, this._comparator)\n        this._root = loadRecursive(undefined, keys, values, 0, size)\n        markBalance(this._root)\n        this._size = size\n        return this\n    }\n\n    /** A tree is 'balanced' if none of the subtrees differ in height by more than 1 */\n    isBalanced() {\n        return isBalanced(this._root)\n    }\n\n    /** String representation of the tree - primitive horizontal print-out */\n    toString(printNode?: (node: Node<K, V>) => string) {\n        return print(this._root, printNode)\n    }\n\n    /** Successor node */\n    static next<K = unknown, V = unknown>(\n        node: Node<K, V>,\n    ): Node<K, V> | undefined {\n        let successor: Node<K, V> | undefined = node\n        if (successor) {\n            if (successor.right) {\n                successor = successor.right\n                while (successor.left) successor = successor.left\n            } else {\n                successor = node.parent\n                while (successor && successor.right === node) {\n                    node = successor\n                    successor = successor.parent\n                }\n            }\n        }\n        return successor\n    }\n\n    /** Predecessor node */\n    static prev<K = unknown, V = unknown>(\n        node: Node<K, V>,\n    ): Node<K, V> | undefined {\n        let predecessor: Node<K, V> | undefined = node\n        if (predecessor) {\n            if (predecessor.left) {\n                predecessor = predecessor.left\n                while (predecessor.right) predecessor = predecessor.right\n            } else {\n                predecessor = node.parent\n                while (predecessor && predecessor.left === node) {\n                    node = predecessor\n                    predecessor = predecessor.parent\n                }\n            }\n        }\n        return predecessor\n    }\n}\n\nexport default AVLTree\n"],"names":["const","let"],"mappings":"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"}